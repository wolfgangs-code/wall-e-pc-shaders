	#include "scat_skin.h"
	#include "hlsl_shadow.h"

  	float4 ph_base (const VS_ScatOutput i) : COLOR
	{
		float2	uv=GetDiffuseUV(i);
		float4	tDiffuse = tex2D(sDiffuse,uv.xy);
 
	#ifdef	bOcclusion
		float3	skylight=lerp(gDSkyAmbient.rgb, gDSkyColor.rgb, tex2D(sOcclusion,uv.xy).r );
	#else
		float3	skylight=gDSkyColor.xyz;
	#endif
  
	#ifdef	bSpecular
		float4	specularcolor=tex2D(sSpecular,uv.xy);
	#else
		float4	specularcolor=float4(0,0,0,0);
	#endif
	   
	#ifdef	bNormal												//Normal Map ?	
		float3x3 mTexSpace;
		mTexSpace[0]=float3(i.TexSpace.axe0.xyz);
		mTexSpace[1]=float3(i.TexSpace.axe1.xyz);
		mTexSpace[2]=float3(i.TexSpace.axe2.xyz);
		float3	tOrgNormal = 2 * tex2D( sNormal, uv.xy).xyz - 1;
		float3	normal=mul(tOrgNormal ,mTexSpace);
		normal=normalize(normal);
	#else
		#ifdef	bNormalLocal
		float3	normal = 2 * tex2D( sNormalLocal, uv.xy).xyz - 1;
		normal=normalize(normal);
		#else
		float3	normal = i.TexSpace.normal;						// Vertex normal
		#endif
	#endif
		
	
	#ifdef	bShadowMap
		#ifdef	bShadowMapNoise
			float2 noiseUV = ComputeShadowNoiseUV( i.shadowNoiseUv );	
			float shadow = PixelShadowNoise(i.shadowtcproj, noiseUV, i.shadowNoiseUv.z);
		#else
			float shadow = PixelShadow4(i.shadowtcproj);
		#endif
	#else
		float shadow = 1;
	#endif
	
	#ifdef	bOcclusion
		float	occlusion= tex2D(sOcclusion,uv.xy).r;
	#else
		float	occlusion=1;
	#endif

		float3 eye = normalize(i.eyevec);
		
	   	float3 lightv = lighting(	normal.xyz,
									gDLight.Dir.xyz,gDSkyDir.xyz,
									eye.xyz,
									gDSunColor.rgb,skylight.rgb,		
									tDiffuse.rgb,		//color vertex	
									specularcolor.r,
									shadow );
		 
		tDiffuse.xyz =lightv;
		tDiffuse.xyz *= i.extinction.xyz;
		tDiffuse.xyz += i.inscatter.xyz;
		
		#ifdef _X360
			tDiffuse.xyz = PackHDRSample( tDiffuse.xyz );
		#endif
		
		return	tDiffuse;
	}

	const float4x4 gLocalToWorldNormalMatrix;
	
  	float4 ph_car (const VS_ScatOutput i) : COLOR
  	{
		float2	uv=GetDiffuseUV(i);

		//Morphing, resultat du morphing qui blend la diffuse et la normal map
		float	morph=GetBroken(i);
		
	#ifdef	bBroken
		//Blend Diffuse Cassé
		float2 halfuv=float2(uv.x*0.5f,uv.y);		
		float4	tDiffuse = tex2D(sDiffuse,halfuv);
	#else
		float4	tDiffuse = tex2D(sDiffuse,uv);
	#endif
			
	#ifdef	bColoured
		//Car paint color
		tDiffuse.rgb = lerp( gGouraudDefault, tDiffuse.rgb, tDiffuse.a );
		tDiffuse.a = 1.0f;
	#endif
	
		float	dirtiness = GetDirtiness(i);

	#ifdef	bDirt
		float4  tDirt = tex2D(sDirt,uv.xy);
		const float dirtTransition = 0.15f;
		dirtiness = 1.0f - dirtiness;
		dirtiness = smoothstep(	dirtiness, dirtiness + dirtTransition, tDirt.a );
				
		tDiffuse.rgb = lerp( tDiffuse.rgb, tDirt.rgb, dirtiness );
	#endif
	
	#ifdef	bOcclusion
		float	occlusion=tex2D(sOcclusion,uv.xy).r;
	#else
		float	occlusion=1;
	#endif
  
	#ifdef	bSpecular
		float4	specularcolor=tex2D(sSpecular,uv.xy);
	#else
		float4	specularcolor=float4(0,0,0,0);
	#endif
	   
	#ifdef	bNormal												//Normal Map ?	
		float3x3 mTexSpace;
		mTexSpace[0]=float3(i.TexSpace.axe0.xyz);
		mTexSpace[1]=float3(i.TexSpace.axe1.xyz);
		mTexSpace[2]=float3(i.TexSpace.axe2.xyz);
		float3	tOrgNormal = (2 * tex2D( sNormal, uv.xy) - 1);
		float3	normal=mul(tOrgNormal ,mTexSpace);
		normal=normalize(normal);
	#else
		#ifdef	bNormalLocal
			#ifdef	bBroken
			float3 normal = 2*tex2D(sNormalLocal, halfuv)-1;
			#else
			float3 normal = 2*tex2D(sNormalLocal, uv)-1;
			#endif
		normal=normalize(normal);
		#else
		float3	normal = i.TexSpace.normal;						// Vertex normal
		#endif
	#endif
		
	
	#ifdef	bShadowMap
		#ifdef	bShadowMapNoise
			float2 noiseUV = ComputeShadowNoiseUV( i.shadowNoiseUv );	
			float shadow = PixelShadowNoise(i.shadowtcproj, noiseUV, i.shadowNoiseUv.z);
		#else
			float shadow = PixelShadow9(i.shadowtcproj);
		#endif
	#else
		float shadow = 1;
	#endif
	
		float3 eye = normalize(i.eyevec);
		
	   	float3 lightv = lighting(	normal.xyz,
									gDLight.Dir.xyz,gDSkyDir.xyz,
									eye.xyz,
									gDSunColor.rgb,lerp(gDSkyAmbient.rgb,gDSkyColor.rgb,occlusion),		
									tDiffuse.rgb,			//color vertex	
									specularcolor.r,	//ou est passé le specular color ??
									shadow );
		 
		tDiffuse.xyz =lightv;
		tDiffuse.xyz *= i.extinction.xyz;
		tDiffuse.xyz += i.inscatter.xyz;

	//Cubemap reflexion
		float3 vReflect = reflect( -eye, normal );
		vReflect.z = -vReflect.z; //TODO fix this hack
		
		vReflect = mul( float4(vReflect, 0), gLocalToWorldNormalMatrix ).xyz;
						
		#ifdef _X360
			float3 reflection = UnpackHDRSample( texCUBE( sGlobalCube, vReflect ) );
		#else
			float3 reflection = texCUBE( sGlobalCube, vReflect ).rgb;
		#endif
		
		float fNdotV = 1.0 - saturate( dot( eye, normal )); // Fresnel term
		float fFresnel = fNdotV * fNdotV;
		fFresnel = fFresnel * 0.7f + 0.3f;
		float cubemapInfluence = fFresnel * ( 1-dirtiness );

		tDiffuse.xyz = lerp( tDiffuse.xyz, reflection, cubemapInfluence*specularcolor.r );
	
		#ifdef _X360
			tDiffuse.xyz = PackHDRSample( tDiffuse.xyz );
		#endif
		
		return	tDiffuse;
  	}
  	
 